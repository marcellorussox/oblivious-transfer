import random
from cryptography.hazmat.primitives.ciphers import Cipher, algorithms, modes
from cryptography.hazmat.backends import default_backend
from cryptography.hazmat.primitives import serialization, hashes
from cryptography.hazmat.primitives.asymmetric import rsa, dh
from cryptography.hazmat.primitives.kdf.hkdf import HKDF
from cryptography.hazmat.primitives import hashes
from cryptography.hazmat.primitives import padding
import os
import json
import logging

# Configure logging for better debugging and insight into protocol execution
logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')

def get_large_prime(bits=1024):
    """
    Generates a large prime number suitable for cryptographic operations.
    The number of bits determines the size of the prime.
    For 100 decimal digits, you'd need approximately log2(10^100) bits = 100 * log2(10) ~ 100 * 3.32 ~ 332 bits.
    A 1024-bit prime is much larger than 100 decimal digits, ensuring high security.
    """
    # For actual prime generation, we'd typically use a robust library.
    # The 'cryptography' library can help with DH parameters, which include safe primes.
    # Here, we'll leverage a simple (though not cryptographically strong for direct use)
    # approach for pedagogical purposes, or better, rely on parameters generated by 'cryptography'.

    # The 'cryptography' library provides functions to generate Diffie-Hellman parameters,
    # which include a safe prime (p) and a generator (g). This is generally preferred
    # over generating a raw prime yourself for security-critical applications.
    logging.info(f"Generating a {bits}-bit Diffie-Hellman prime parameter...")
    parameters = dh.generate_parameters(generator=2, key_size=bits, backend=default_backend())
    p = parameters.parameter_numbers().p
    g = parameters.parameter_numbers().g
    logging.info(f"Generated prime (p) with {p.bit_length()} bits.")
    # Ensure the prime has at least 100 decimal digits
    if len(str(p)) < 100:
        logging.warning(f"Generated prime has {len(str(p))} decimal digits, which is less than 100. Consider increasing bit size.")
        # In a real scenario, we might re-generate. For this project, we'll proceed.
    return p, g

def mod_inv(a, m):
    """
    Computes the modular multiplicative inverse of a modulo m using the extended Euclidean algorithm.
    i.e., finds x such that (a * x) % m == 1.
    Raises ValueError if no inverse exists (i.e., if gcd(a, m) != 1).
    """
    logging.debug(f"Calculating modular inverse of {a} mod {m}")
    g, x, y = egcd(a, m)
    if g != 1:
        raise ValueError(f"Modular inverse does not exist for {a} mod {m}")
    return x % m

def egcd(a, b):
    """
    Extended Euclidean Algorithm: Returns (gcd(a, b), x, y) such that a*x + b*y = gcd(a, b).
    """
    if a == 0:
        return (b, 0, 1)
    else:
        g, y, x = egcd(b % a, a)
        return (g, x - (b // a) * y, y)

def bytes_to_long(b):
    """Converts a byte string to a long integer."""
    return int.from_bytes(b, 'big')

def long_to_bytes(n, block_size=0):
    """
    Converts a long integer to a byte string.
    If block_size is specified, the output bytes will be padded to that size.
    """
    if n < 0:
        raise ValueError("Cannot convert negative number to bytes.")
    if block_size == 0:
        # Determine minimum number of bytes needed
        return n.to_bytes((n.bit_length() + 7) // 8 or 1, 'big')
    else:
        return n.to_bytes(block_size, 'big')

def xor_bytes(a, b):
    """XORs two byte strings of equal length."""
    if len(a) != len(b):
        raise ValueError("Byte strings must have equal length for XOR operation.")
    return bytes(x ^ y for x, y in zip(a, b))

def serialize_data(data):
    """Serializes a dictionary to a JSON string, then encodes to bytes."""
    return json.dumps(data).encode('utf-8')

def deserialize_data(data_bytes):
    """Deserializes bytes (JSON string) to a Python dictionary."""
    return json.loads(data_bytes.decode('utf-8'))

def pad_message(message_bytes, block_size):
    """Pads message bytes using PKCS7 padding to a multiple of block_size."""
    padder = padding.PKCS7(block_size * 8).padder()
    padded_data = padder.update(message_bytes) + padder.finalize()
    return padded_data

def unpad_message(padded_message_bytes, block_size):
    """Unpads message bytes using PKCS7 padding."""
    unpadder = padding.PKCS7(block_size * 8).unpadder()
    unpadded_data = unpadder.update(padded_message_bytes) + unpadder.finalize()
    return unpadded_data
